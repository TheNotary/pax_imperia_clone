<html>
    <head>
        <script type="importmap">
            {
              "imports": {
                "three": "https://unpkg.com/three@0.147.0/build/three.module.js"
              }
            }
          </script>

        <link rel="stylesheet" href="../css/style.css">
    </head>
    <h1>System: Sol</h1>

    <div>
        <span class="console-message" id="console-message">
            Game Paused
        </span></div>

    <div class="flex-container">
        <div class="planet-list">
            <h3>Planets:</h3>
            <ul>
                <li>Mercury</li>
                <li>Venus</li>
                <li>Earth</li>
                <li>Mars</li>
                <li>Jupiter</li>
                <li>Saturn</li>
                <li>Uranus</li>
                <li>Neptune</li>
                <li>Pluto</li>
            </ul>
            <button>Governor</button>
        </div>

        <div>
            <div id="canvas-div"></div>
            <!-- <canvas id="canvas" width="800" height="600" style="border: solid 1px;"></canvas> -->
        </div>

        
    </div>

    <div>
        Lower Console
    </div>


<script type="module">

    import * as THREE from 'three';
    import { GLTFLoader } from "https://cdn.jsdelivr.net/npm/three@0.147.0/examples/jsm/loaders/GLTFLoader.js";

    var t = 0;


    const renderer = new THREE.WebGLRenderer();

    const width = 800;
    const height = 600;
    renderer.setSize( width, height );
    renderer.shadowMap.enabled = true;
    renderer.gammaOutput = true;
    document.getElementById("canvas-div").appendChild( renderer.domElement );


    const consoleSpan = document.getElementById("console-message");


    // Click detection
    const raycaster = new THREE.Raycaster();
    window.pointer = new THREE.Vector2(1,1);
    
    
    const scene = new THREE.Scene();

    ////////////////
    // Add Lights //
    ////////////////

    var light = new THREE.DirectionalLight( 0xffffff, 1 );
    light.position.set(22, 22, 25);
    light.lookAt(0,0,0);
    scene.add( light );
    
    light = new THREE.DirectionalLight( 0xffffff, 1 );
    light.position.set(2, 2, 5);
    light.lookAt(0,0,0);
    scene.add( light );

    light = new THREE.AmbientLight( 0xffffff, 0.1 );
    //light.position.set(-10, -10, 5);
    //light.lookAt(0,0,0);
    scene.add( light );

    ///////////////////
    // Add    Camera //
    ///////////////////

    const camera = new THREE.PerspectiveCamera( 15, width / height, 0.1, 1000 );
    camera.position.set( 0, 100, 0 );
    // camera.position.set( 0, 1, 10 );
    //camera.rotation.set( -90, 0, 0);

    camera.lookAt( 0, 0, 0 );

    var earthScene;

    const loader = new GLTFLoader();
    loader.load( '/public/assets/CloudyPlanet.gltf', function ( gltf ) {

        // Question:
        //   How do I load all the files, and only start the scene after everything is loaded up?
        ////

        ///////////////
        // Add earth //
        ///////////////

        earthScene = gltf.scene;
        // earthScene.scale.set(1.1,1.1,1.1)
        earthScene.position.set(0,0,20)
        scene.add( earthScene );

        console.log("Finished loading!");

    }, function ( xhr ) {
        console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
    }, function ( error ) {
        console.error( error );
    } );

    var sunScene;

    loader.load( '/public/assets/Sun.gltf', function ( gltf ) {
        sunScene = gltf.scene;
        sunScene.position.set(0, 0, 0);
        scene.add( sunScene );

    }, function ( xhr ) {
        console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );
    }, function ( error ) {
        console.error( error );
    } );

    // Add Box for Mouse...
    const boxGeometry = new THREE.BoxGeometry(1,1,1);
    const boxMaterial = new THREE.LineBasicMaterial( { color: 'red' } );
    const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
    scene.add( boxMesh );





    function draw() {
        raycaster.setFromCamera( pointer, camera );
        const intersects = raycaster.intersectObjects( scene.children, false );
        
        boxMesh.position.set(pointer.x, 0, pointer.y);
        // boxMesh.position.set(-17, 0, -12.5);   // this is my X, Y browser mouse translation for (184 / 1472) || 0.125 || top left corner of screen

        // -17 = (184 / 1472) * g
        // g = (-17 * 1472) / 184
        // g = -136

        // debugger;

        for ( let i = 0; i < intersects.length; i ++ ) {
            // alert('hit');
            // debugger;
            // intersects[ i ].object.material.color.set( 0xff0000 );
        }

        t += 1/480;
        if (earthScene != undefined) {
            earthScene.position.x = 10*Math.cos(t) + 0;
            //earthScene.position.y = 5*Math.cos(t) + 0;
            earthScene.position.z = 10*Math.sin(t) + 0;

            //earthScene.rotation.y += 0.005;
        }

        // const whitePlanet = scene.getObjectByName('Scene');
        // if (whitePlanet != undefined) {
        //     whitePlanet.position.x += 0.01;
        //     whitePlanet.rotation.y += 0.005;
        // }

        renderer.render( scene, camera );
        requestAnimationFrame(draw);
    }

    draw();

    function onPointerMove( event ) {
        // calculate pointer position in normalized device coordinates
        // (-1 to +1) for both components
        renderer.domElement;

        const h = renderer.domElement.height;
        const w = renderer.domElement.width;
        const mx = event.clientX -182;
        const my = event.clientY - 85;

        // pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
        // pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

        pointer.x = ( mx/ w ) * 35 - 17;
        pointer.y = ( my/ h ) * 26 - 12.5;


        // Position to top left:
        // pointer.x = -17;
        // pointer.y = -12.5;

        // position to bottom right
        // pointer.x = 18;
        // pointer.y = 13.5;

        // x range:  35
        // x offset: -17
        // y range:  26
        // y offset: -12.5

        // g = (-17 * 1472) / mouse
        // FIXME / TODO: this doesn't work... but I thought it would 
        // pointer.x = (-17 * window.innerWidth ) / event.clientX;
        // pointer.x = (event.clientX * window.innerWidth ) / -136;
        

        // pointer.x = -163 / (event.clientX * window.innerWidth);
        // pointer.y =  -12.5 + (event.clientY * window.innerHeight ) / 130;



        // pointer.y = (event.clientY * window.innerHeight ) / g-y
        // g-y = (-12.5 * 783 ) / 88
        // g-y = -111


        // TODO: finish equation for pointer to x,y,z mapping
        // ( event.clientX / window.innerWidth ) + xOffsetOfCanvas


        // top left is -1, 1
        // consoleSpan.innerHTML = "Pointer {" + pointer.x + ", " + pointer.y + "}";
        // consoleSpan.innerHTML = "event.clientX / window.innerWidth:  {" + event.clientX + " / " + window.innerWidth + "}";
        var msg = "";
        // msg = "my / h:  {" + my + " / " + h + "} = " + my / h;
        // msg += " | g = " + -12.5 / (my / h);
        msg = "mx / w:  {" + mx + " / " + w + "} = " + mx / w;
        // msg += " | g = " + -12.5 / (mx / w);

        // msg = "event.clientY / window.innerHeight:  {" + event.clientY + " / " + window.innerHeight + "} = " + event.clientY / window.innerHeight;
        // msg += " | g = " + -12.5 / (event.clientY / window.innerHeight);

        // msg = "event.clientX / window.innerWidth:  {" + event.clientX + " / " + window.innerWidth + "} = " + event.clientX / window.innerWidth;
        // msg += " | g = " + -17 / (event.clientX / window.innerWidth);
        
        // msg = "pointer.x, y = { " + pointer.x + ", " + pointer.y + " }";
        consoleSpan.innerHTML = msg;

        // pointer.x = ( event.clientX / renderer.domElement.width ) * 20 - 20;
        // pointer.y = - ( event.clientY / renderer.domElement.height ) * 20 + 20;
    }

    renderer.domElement.addEventListener( 'pointermove', onPointerMove );


    // DRAW BOX

    // const boxGeometry = new THREE.BoxGeometry(1,1,1);
    // const boxMaterial = new THREE.LineBasicMaterial( { color: 'red' } );
    // const boxMesh = new THREE.Mesh(boxGeometry, boxMaterial);
    // scene.add( boxMesh );

    // // DRAW LINE
    // const points = [];
    // points.push( new THREE.Vector3( - 10, 0, 0 ) );
    // points.push( new THREE.Vector3( 0, 10, 0 ) );
    // points.push( new THREE.Vector3( 10, 0, 0 ) );

    // const lineGeometry = new THREE.BufferGeometry().setFromPoints( points );
    // const lineMaterial = new THREE.LineBasicMaterial( { color: 0x0000ff } );
    // const line = new THREE.Line( lineGeometry, lineMaterial );
    // scene.add( line );

    // // DRAW SPHERE
    // const geometry = new THREE.SphereGeometry( 15, 32, 16 );
    // const material = new THREE.MeshBasicMaterial( { color: 0xffff00 } );
    // const sphere = new THREE.Mesh( geometry, material );
    // scene.add( sphere );



  </script>
  
    

</html>